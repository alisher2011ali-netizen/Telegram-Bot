import csv
import os

FILENAME = "terms_data.csv"

terms_data = {
    "Алгоритм (программа)": {
        "definition": "Упорядоченный набор инструкций для выполнения некоторой задачи",
        "example": "Рецепт приготовления блюда: последовательность действий для получения готового блюда. Инструкция по сборке мебели: пошаговое руководство для сборки. "
    },
    "Python": {
        "definition": "Это язык программирования с простым и понятным синтаксисом, похожим на английский язык, который используется для создания программ и веб-сайтов. Он очень популярен, потому что его легко изучать новичкам и он подходит для решения широкого спектра задач.",
        "example": "Кроме Python существует множество других, очень отличающихся между собой языков, как Java, JavaScript, C++, C#, HTML, SQL, PHP, GO, Rust, Ruby, Паскаль, ну и один из самых старых и сложных - Assembly"
    },
    "Среды разработки (IDE)": {
        "definition": "Это приложение с инструментами для написания, отладки и запуска кода.",
        "example": "Наиболее популярный вариант именно для питона это PyCharm. Но также есть и другие IDE, и самой лучшей я считаю VS Code (Visual Studio Code), так как интерфейс очень удобный и не нужно заморачиваться над интерпретаторами, отладчиками и т.п. Все можно скачать из магазина расширений прямо в программе. Также есть возможность подключть ИИ-помощника, у которого можно спрашивать как устранить ту или иную ошибку, или как можно сделать подобную программу. И главное преимущество - можно программировать на почти ВСЕХ языках, а у PyCharm всего несолько доступных языков, кроме питона. Именно эта программа создана в VS Code."
    },
    "Синтаксис": {
        "definition": "Набор правил, определяющих, как правильно писать код на конкретном языке.",
        "example": "SyntaxError: invalid syntax — это ошибка, означающая, что в вашем коде есть нарушение правил языка программирования, например, опечатки или отсутсвие некоторых символов."
    },
    "Переменная (var)": {
        "definition": "Именованное место в памяти.",
        "example": "age = 15"
    },
    "Функция print": {
        "definition": "Функция, которая выводит данные в консоль.",
        "example": "print('Hello, world!')"
    },
    "Тип данных int (целые числа)": {
        "definition": "Любые целые числа (в том числе отрицательные и 0).",
        "example": "8, 56, 192"
    },
    "Тип данных float (вещественные числа)": {
        "definition": "Числа с плавающей точкой, т.е с цифрами после запятой.",
        "example": "4.5, 76.423"
    },
    "Арифметические операции": {
        "definition": "Сложение, вычитание, деление и умножение как обычно (+, -, /, *). Но в Python также есть деление без остатка (всегда будет целое число - частное) 2 знак деления (//). Деление с остатком (всегда будет целое число - остаток) знак %. Также есть степень, 2 знака умножения (**). Также есть функция abs(), которая работает как модуль числа.",
        "example": """a = 1 + 2
b = 5 - 3
c = 10 / 2
d = 3 * 4
e = 17 // 5 #Частное без остатка 3
f = 17 % 5 #Остаток без частного 2
g = 3 ** 3 #Т.е 3 в степени 3 = 27
h = abs(5 - 7) #Будет 2 (т.е всегда НЕотрицательное)"""
    },
    "Тип данных str (строки)": {
        "definition": "Строка с символами внутри двойных или ординарных кавычек.",
        "example": "'Привет!', 'How are you?'"
    },
    "Форматирвоание с помощью f": {
        "definition": "Внутрь строк можно вставлять переменные, не делая их через запятые или используя + (пример: name = 'Alice' print('Hello, ', name)). Если вставляемых переменных будет много это будет очень неудобно. Но написав f в начале строки, можно вставлять их сразу внутрь с помощью фигурных скобок.",
        "example": """name = 'John' age = 21
    print(f'My name is {name}, I'm {age} years')"""
    },
    "Тип данных bool (логические значения)": {
        "definition": "Может принимать 2 значения: истинное (True) или ложное (False).",
        "example": "value = True."
    },
    "Тип данных list (списки или массивы)": {
        "definition": "Упорядоченный и изменяемый набор элементов, которые хранятся в одной переменной. В Python в списках могут хранится разные типы данных.",
        "example": "students = [Mary, Michael, Andrew, Suisy]"
    },
    "Тип данных tuple (кортежи)": {
        "definition": "Те же самые списки, только они не изменяются.",
        "example": "family = ('dad', 'mum', 'son', 'daughter')"
    },
    "Тип данных dict (словари)": {
        "definition": "Неупорядоченная коллекция элементов, где каждый элемент представляет собой пару «ключ-значение». Ключи должны быть уникальными, а значения могут повторяться. Обозначается фигурными скобками.",
        "example": "my_dict = {name: 'Alex', age: 20, city: 'New York'}"
    },
    "Тип данных set (множества)": {
        "definition": "Он хранит только уникальные элементы в ординарном кол-ве. Одинаковые он просто отбросит.",
        "example": """my_set = {0, 1, 4, 2, 3, 3, 2, 4}
    print(my_set)
#Вывод: {0, 1, 2, 3, 4}"""
    },
    "Типизация": {
        "definition": "Механизм, который помогает программе понять, как работать с разными типами данных. От типа зависит, как данные хранятся и какие действия с ними можно выполнять.",
        "example": """name = 'Jane'
    age = 30
    print(name + age)
#Если сложить строку и число, Python выдаст ошибку."""
    },
    "Duck Typing (Утиная типизация)": {
        "definition": """Философия динамической типизации в Python, которая гласит: "Если что-то выглядит как утка и крякает как утка, то это, вероятно, утка". Суть в том, что важен набор методов объекта, а не его явный тип.""",
        "example": ""
    },
    "ASCII символы": {
        "definition": "Это 128 стандартных символов, таких как латинские буквы, цифры, знаки препинания и управляющие символы, которые были закодированы для представления текста на компьютере. Является основой для многих современных кодировок, таких как UTF-8, что обеспечивает совместимость между различными системами и платформами.",
        "example": "У английской заглавной буквы 'A' номер 65, а в символе '0' - 48."
    },
    "Функкции ord и chr": {
        "definition": "Функции ord() и chr() - это парные встроенные функции для работы с кодировкой Unicode: ord(symbol) преобразует символ (строку из одного символа) в его числовой код, а chr(number) делает обратное — преобразует целое число в соответствующий ему символ.",
        "example": """symbols = ord("A")
print(symbols) #Выведет 65, т.к у этого символа такой номер

numbers = chr(48)
print(numbers) #Выведет 0, т.к у этого символа такой номер"""
    },
    "Цикл for": {
        "definition": "Повторение действий N-ое количество раз.",
        "example": """for i in range(5):
        print(i)"""
    },
    "Функция range": {
        "definition": "Генерирует итератор, ввиде последовательности целых чисел. Если вводится только 1 значение, то это будет концом (при этом сам конец не включается). Если указано 2, то первое будет началом (по умолчанию 0), в второе значение - концом. Если 3 числа, то первые два начало и конец, а 3 - шаг, т.е какая будет разница между числами. ",
        "example": """for i in range(5): #Числа от 0 до 4
for i in range(1, 6) #Числа от 1 до 5
for i in range(1, 10, 2) #Каждые 2 числа от 1 до 10"""
    },
    "Цикл while": {
        "definition": "Повторение действий, пока условие выполняется. В самом цикле обязательно указать как изменятся счетчик, иначе цикл будет БЕСКОНЕЧНЫМ.",
        "example": """while k <= 5:
        print(k) k = k + 1"""
    },
    "Оператор break": {
        "definition": "Он останаливает цикл и выходит из него.",
        "example": """for i in range(5):
        print(i) if i == 4:
        break
Цикл прекратится когда i будет равно 4."""
    },
    "Итерация": {
        "definition": "Это один проход цикла.",
        "example": """for i in range(5):
        print(i)
Здесь: вывод i является итерацией)"""
    },
    "Итератор": {
        "definition": "объект, чтобы перебирать элементы последовательности (списка, кортежа и пр.)",
        "example": """for i in range(5): #Функция range создает итератор - последоватльность чисел от 0 до 4
        print(i)"""
    },
    "List Comprehension (Списочные включения)": {
        "definition": "Краткий и читаемый синтаксис для создания списков на основе существующих итераций.",
        "example": """squares = []
for x in range(5):
    squares.append(x**2)
#Это был обычный способ

squares = [x**2 for x in range(5)]
#А это кратким способом, но списки у них будут одинаковыми"""
    },
    "Условные операторы if, elif и else": {
        "definition": "if - начальное условие, при его выполнении выполняется код снизу. Если условия нет, то оно будет проверять есть ли этот объект вообще. elif - условие, которое будет проверено только если if не было выполнено. Если ни одно условие не было выполнено, то код будет работать по сценарию else.",
        "example": """if 1:
        print('True')"""
    }, 
    "Оператор is": {
        "definition": "Оно проверяет идентичные ли объекты. Может заменяться на ==.",
        "example": """if 1 == 1:
        print('Yes')"""
    },
    "Оператор in": {
        "definition": "Оно проверяет принадлежит ли этот объект другому, или есть ли он внутри него.",
        "example": """my_list = [0, 1, 2, 3, 4]
if 4 in my_list:
        print('Yes')"""
    },
    "Операции and, or и not": {
        "definition": "Это логические оперцации. and - И, or - ИЛИ, not - НЕ.",
        "example": """if 'a' == 'a' and 'b' == 'd'
        print('Yes')"""
    },
    "Декомпозиция": {
        "definition": "Это разделение сложной задачи на более мелкие и управляемые компоненты, это делет код более читаемым.",
        "example": "Например в Python это классы и функции."
    },
    "Функции": {
        "definition": "Блок кода, который выполняется только при вызове. Определяется с ключевым словом def, за которым следует имя функции, скобки с параметрами и двоеточиe.",
        "example": """def my_func(*args):
        return args * 2
#Эта функция возвращает удвоенное значение переменной"""
    },
    "Функция return": {
        "definition": "Он используется внутри функции, при использоваии завершает ее выполнение и возвращает опредленное значение.",
        "example": "return 0",
    },
    "lambda функция": {
        "definition": "Небольшая функция без имени, которая определяется ключевым словом lambda. В теле такой функции можут быть только одно выражение.",
        "example": """my_func = lambda x: x * 2
print(my_func(5))"""
    },
    "Ключевое слово global": {
        "definition": "Используется внутри функции, когда вы хотите приосвоить новое значение переменной, которая была объявлена вне функции.",
        "example": """counter = 0
def my_func():
    global counter
    counter = 10
#В итоге изменится переменная не локально (внутри функции) а во всем коде (глобально)."""
    },
    "Функции sorted и filter": {
        "definition": "sorted (сортировка) - меняет порядок элементов по определенному признаку, не изменяя кол-во элеменов. По умолчанию сортирует по размеру. filter (фильтрация) - выбирает элементы по определенному признаку, некоторые элементы могут быть НЕ включены в конечную выборку. Обязательно нужен ключ ввиде функции, по которой и просиходит фильтрация. Оригинальный массив они НЕ ИЗМЕНЯЮТ.",
        "example": """def is_even(x):
        return x % 2 == 0

my_list = [1, 5, 4, 2, 3]
sorted(my_list) #Вывод: [1, 2, 3, 4, 5]
filter(my_list, is_even) #Вывод: [2, 4] (т.е только четные)"""
    },
    "Декораторы": {
        "definition": "Это функции, которые могут модифицировать поведение других функций, при этом не изменяя их исходного кода. Определяется как функция (с помощью def), а чтобы использовать ее как декоратор нужно перед названием поставить @, снизу другая функция.",
        "example": """def function(func):
        def wrapper(*args, **kwargs):
            # Дополнительная логика ДО вызова оригинальной функции
            print(f"--- Вызывается функция: {func.__name__} ---")
        
            # Вызов оригинальной функции и сохранение результата
            result = func(*args, **kwargs)
        
            # Дополнительная логика ПОСЛЕ вызова оригинальной функции
            print(f"--- Функция {func.__name__} завершила работу ---")
        
        # Возврат результата оригинальной функции
        return result
    
    # Декоратор возвращает новую (обернутую) функцию
    return wrapper
@function def say_hello(name):
    print('Hello, {name}!')"""
    },
    "О-большое": {
        "definition": "Это способ оценить, насколько медленнее или быстрее будет работать программа (алгоритм). Это не точное время в секундах, а математическая запись, описывающая, как растет сложность алгоритма с ростом объема входных данных (n). При этом, О-большое рассматривает худший случай, а не средний.",
        "example": """O(n) (Линейная сложность): Как перебор всех карточек по одной. Если карточек 10, займет 10 шагов.
O(log n) (Логарифмическая сложность): Как бинарный поиск в отсортированной стопке. Вы делите стопку пополам, отбрасываете ненужную, и так далее.
O(n²) (Квадратичная сложность): Как если бы вы сравнивали каждую карточку с каждой другой. Если карточек 10, нужно 100 сравнений."""
    },
    "Рекурсия": {
        "definition": "Метод решения задачи, при котором функция вызывает сама себя для решения более простых подзадач.",
        "example": """def sum_recursicve(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return n + sum_recursicve(n-1) #Здесь функция вызывает сама себя. При этом n каждый раз уменьшается на 1, а прошлое значения n осталось в памяти"""
    },
    "Бинарный поиск": {
        "definition": "Это алгоритм нахождения места (игдекса) элемента в ОТСОРТИРОВАННОМ массиве. Его принцип в том, что мы многократно (рекурсивно) делим массив пополам и проверяем, есть ли в этой половние наш элемент. Его скорость O(log n)",
        "example": """def binary_find(lst: list, value: int) -> int: #Функция вернет нам индекс ввиде целого числа
    if not lst:
        return None #Если список пустой, то там нечего искать
    
    mid = len(lst) // 2 #Находим значение в середине без остатка
    mid_value = lst[mid]

    if value == mid_value:
        return mid #Проверка на совпадение
    elif value < mid_value:
        return binary_find(lst[:mid], value) #Если значение меньше, то функция запускается снова, но в списке будет только первая половина
    else:
        result = binary_find(lst[mid + 1:], value) #Если значение больше, то функция запускается снова, но в списке будет вторая половина
        return result + mid + 1 if result is not None else None #Если он не найдет, то вернется None (ничего)"""
    },
    "Быстрая сортировка": {
        "definition": "это алгоритм, который делит большой массив на два меньших подмассива на основе опорного элемента, а затем рекурсивно сортирует каждый из них. Его главные принципы — «разделяй и властвуй», что обеспечивает в среднем O(n log n) время работы.",
        "example": """import random

def quicksort_random(arr):
    if len(arr) <= 1: #Если список содержит 0 или 1 элемент, он уже считается отсортированным
        return arr
    
    pivot = random.choice(arr)  #Опорный элемент может быть первым, последним или случайным(что является самым лучшым вариантом)
    left = [x for x in arr if x < pivot] #left: Содержит все элементы, которые меньше pivot.
    middle = [x for x in arr if x == pivot] #middle: Содержит все элементы, которые равны pivot. (Это важно, если в списке есть дубликаты)
    right = [x for x in arr if x > pivot] #right: Содержит все элементы, которые больше pivot.
    
    return quicksort_random(left) + middle + quicksort_random(right) #Алгоритм рекурсивно вызывает сам себя для сортировки списка left и right, а middle ставит в середину, т.к он равен опорному элементу"""
    },
    "Исключение": {
        "definition": "событие, которое возникает при выполнении программы, когда что-то идет не так.",
        "example": "При попытке сложить разные типы данных (к примеру строку и целое число) выйдет ошибка, это и есть исключение."
    },
    "Конструкция try, except и finally": {
        "definition": "try используется для обработки ошибок в коде. В except находится код, который выполнится при ошибке. В finally код выполнится в любом случае, даже если ошибок не было.",
        "example": """def safe_division():
    try:
        # --- Блок TRY: Попытка выполнить потенциально опасный код ---
        # Мы пытаемся получить ввод от пользователя и преобразовать его в число.
        user_input = input("Введите число для деления 100 на него: ")
        number = int(user_input)
        
        # Мы пытаемся выполнить деление
        result = 100 / number
        print(f"Результат деления: {result}")

    except ValueError:
        # --- Блок EXCEPT (если произошла ошибка типа ValueError) ---
        # Это сработает, если пользователь ввел НЕ число (например, 'привет')
        print("Ошибка! Вы ввели неверный тип данных. Пожалуйста, введите целое число.")
        
    except ZeroDivisionError:
        # --- Блок EXCEPT (если произошла ошибка типа ZeroDivisionError) ---
        # Это сработает, если пользователь ввел 0
        print("Ошибка! Нельзя делить на ноль.")

    finally:
        # --- Блок FINALLY: Выполняется ВСЕГДА (была ошибка или нет) ---
        print("--- Попытка операции завершена. ---")
        print("--- Программа продолжает работу. ---")

safe_division()"""
    },
    "ООП": {
        "definition": "Объектно-ориентированное программирование - это подход к написанию программ, который имитирует взаимодейтсвие реальных объектов. Она рассматривает программу как набор предметов, взаимодействующих друг с другом.",
        "example": "Вы строите дом не по отдельным кирпичам, а разделяете весь дом на разные части и собираете его как конструктор. Кстати, данная программа тоже создана с пмощью ООП)"
    },
    "Классы": {
        "definition": "Шаблоны или чертежи для создания объектов. Они определяют набор свойств (атрибутов) и действий (методов), которые будут присущи всем объектам этого класса. Определятся с ключевым словом class.",
        "example": """class Buildings():
        def __init__(self):
            self.type = type
            self.heigth = height
            self.year = year
        def get_info():
            print(f"Type: {self.type}, height: {self.height}, year: {self.height}")"""
    },
    "Инкапсуляция": {
        "definition": "Проще говоря это и есть создание класса, т.е объединение переменных и функций внутри одного объекта (класса). Но также это ограничение доступа к данным и методам внутри этого класса во избежание ошибок.",
        "example": "class MyClass(): def __str__(self): (__str__ - это приватный атрибут)",
    },
    "Наследование": {
        "definition": "Это механизм, который позволяет создавать новые классы на основе уже существующих. Новый класс наследует свойства и методы родительского класса, что позволяет повторно использовать код не создавая множество одинаковых классов. Вы можете использовать ключевое слово class для создания нового класса и указать базовый класс в скобках.",
        "example": "class Schools(Buildings): (подразумеватся что класс Buildings уже есть)"
    },
    "Полиморфизм": {
        "definition": "Способность разных объектов по-разному реагировать на одно и то же действие (вызов одной и той же функции).",
        "example": "У собаки и у кошки есть действие 'издать_звук()', но, используя полиморфизм, собака будет издавать лай, а кошка мяукание",
    },
    "Абстракция": {
        "definition": "Простыми словами: Сосредоточение на том, что объект делает, а не на том, как он это делает. Сокрытие сложных деталей.",
        "example": "Вы используете телефон, и чтобы позвонить вам не нужно знать как этот сигнал преобразуется в элетромагнитные волны, передается на сервера, как запрос отправляется на телефон другого человека и т.д. Все детали скрыты под крышкой",
    },
    "Модуль": {
        "definition": "Файл Python, который можно импортировать в локальное пространство вашего файла с пмошью import. Если хотите несколько то from (имя файла) import (названия функций). Чтобы импортировать все, нужно написать import *.",
        "example": "import sys",
    },
    "Менеджер контекста": {
        "definition": "Объект, который управляет ресурсами (например, файлами или сетевыми соединениями), автоматически открывая и закрывая их, часто используется с оператором with.",
        "example": """with open('file_name.txt', 'r') as file: #Здесь файл открывается для чтения с именем file
        content = file.read() #Создает "читателя", который и сканирует наш файл
        print(content) #Выводит то, что он прочитал в файле
#Так как блок with завершился, то он автоматически закроет файл"""
    },
    "JSON": {
        "definition": "JavaScript Object Notation - текстовой формат обмена данными. В питоне предустановлена библиотека json и она может использоваться если вы работаете с несколькими языками, а вам нужно использовать одну и ту же информацию.",
        "example": "my_list = json.dumps(['apple', 'orange', 'avacado', 'onion'] (.dumps() - метод json, который запаковывает данные в этот формат)",
    },
    "pip (Pip Installs Packages)": {
        "definition": "Это стандартный менеджер пакетов Python для установки, обновления и удаления сторонних библиотек через командную строку.",
        "example": "(Пишется в консоль) pip install <название библиотеки>",
    }

}

def create_csv_from_dict(data_dict, filename="terms_data.csv"):
    fieldnames = ['terms', 'definition', 'example']

    try:
        with open(filename, "w", newline="", encoding="utf-8") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames, delimiter=",")

            writer.writeheader()

            for term_name, term_details in data_dict.items():
                writer.writerow({
                    'terms': term_name,
                    'definition': term_details['definition'],
                    'example': term_details['example']
                })
    except IOError as e:
        print(f"Ошибка ввода/вывода при создании файла: {e}")

if __name__ == "__main__":
    create_csv_from_dict(terms_data)

