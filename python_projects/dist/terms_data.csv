terms,definition,example
Алгоритм (программа),Упорядоченный набор инструкций для выполнения некоторой задачи,Рецепт приготовления блюда: последовательность действий для получения готового блюда. Инструкция по сборке мебели: пошаговое руководство для сборки. 
Python,"Это язык программирования с простым и понятным синтаксисом, похожим на английский язык, который используется для создания программ и веб-сайтов. Он очень популярен, потому что его легко изучать новичкам и он подходит для решения широкого спектра задач.","Кроме Python существует множество других, очень отличающихся между собой языков, как Java, JavaScript, C++, C#, HTML, SQL, PHP, GO, Rust, Ruby, Паскаль, ну и один из самых старых и сложных - Assembly"
Среды разработки (IDE),"Это приложение с инструментами для написания, отладки и запуска кода.","Наиболее популярный вариант именно для питона это PyCharm. Но также есть и другие IDE, и самой лучшей я считаю VS Code (Visual Studio Code), так как интерфейс очень удобный и не нужно заморачиваться над интерпретаторами, отладчиками и т.п. Все можно скачать из магазина расширений прямо в программе. Также есть возможность подключть ИИ-помощника, у которого можно спрашивать как устранить ту или иную ошибку, или как можно сделать подобную программу. И главное преимущество - можно программировать на почти ВСЕХ языках, а у PyCharm всего несолько доступных языков, кроме питона. Именно эта программа создана в VS Code."
Синтаксис,"Набор правил, определяющих, как правильно писать код на конкретном языке.","SyntaxError: invalid syntax — это ошибка, означающая, что в вашем коде есть нарушение правил языка программирования, например, опечатки или отсутсвие некоторых символов."
Переменная (var),Именованное место в памяти.,age = 15
Функция print,"Функция, которая выводит данные в консоль.","print('Hello, world!')"
Тип данных int (целые числа),Любые целые числа (в том числе отрицательные и 0).,"8, 56, 192"
Тип данных float (вещественные числа),"Числа с плавающей точкой, т.е с цифрами после запятой.","4.5, 76.423"
Арифметические операции,"Сложение, вычитание, деление и умножение как обычно (+, -, /, *). Но в Python также есть деление без остатка (всегда будет целое число - частное) 2 знак деления (//). Деление с остатком (всегда будет целое число - остаток) знак %. Также есть степень, 2 знака умножения (**). Также есть функция abs(), которая работает как модуль числа.","a = 1 + 2
b = 5 - 3
c = 10 / 2
d = 3 * 4
e = 17 // 5 #Частное без остатка 3
f = 17 % 5 #Остаток без частного 2
g = 3 ** 3 #Т.е 3 в степени 3 = 27
h = abs(5 - 7) #Будет 2 (т.е всегда НЕотрицательное)"
Тип данных str (строки),Строка с символами внутри двойных или ординарных кавычек.,"'Привет!', 'How are you?'"
Форматирвоание с помощью f,"Внутрь строк можно вставлять переменные, не делая их через запятые или используя + (пример: name = 'Alice' print('Hello, ', name)). Если вставляемых переменных будет много это будет очень неудобно. Но написав f в начале строки, можно вставлять их сразу внутрь с помощью фигурных скобок.","name = 'John' age = 21
    print(f'My name is {name}, I'm {age} years')"
Тип данных bool (логические значения),Может принимать 2 значения: истинное (True) или ложное (False).,value = True.
Тип данных list (списки или массивы),"Упорядоченный и изменяемый набор элементов, которые хранятся в одной переменной. В Python в списках могут хранится разные типы данных.","students = [Mary, Michael, Andrew, Suisy]"
Тип данных tuple (кортежи),"Те же самые списки, только они не изменяются.","family = ('dad', 'mum', 'son', 'daughter')"
Тип данных dict (словари),"Неупорядоченная коллекция элементов, где каждый элемент представляет собой пару «ключ-значение». Ключи должны быть уникальными, а значения могут повторяться. Обозначается фигурными скобками.","my_dict = {name: 'Alex', age: 20, city: 'New York'}"
Тип данных set (множества),Он хранит только уникальные элементы в ординарном кол-ве. Одинаковые он просто отбросит.,"my_set = {0, 1, 4, 2, 3, 3, 2, 4}
    print(my_set)
#Вывод: {0, 1, 2, 3, 4}"
Типизация,"Механизм, который помогает программе понять, как работать с разными типами данных. От типа зависит, как данные хранятся и какие действия с ними можно выполнять.","name = 'Jane'
    age = 30
    print(name + age)
#Если сложить строку и число, Python выдаст ошибку."
Duck Typing (Утиная типизация),"Философия динамической типизации в Python, которая гласит: ""Если что-то выглядит как утка и крякает как утка, то это, вероятно, утка"". Суть в том, что важен набор методов объекта, а не его явный тип.",
ASCII символы,"Это 128 стандартных символов, таких как латинские буквы, цифры, знаки препинания и управляющие символы, которые были закодированы для представления текста на компьютере. Является основой для многих современных кодировок, таких как UTF-8, что обеспечивает совместимость между различными системами и платформами.","У английской заглавной буквы 'A' номер 65, а в символе '0' - 48."
Функкции ord и chr,"Функции ord() и chr() - это парные встроенные функции для работы с кодировкой Unicode: ord(symbol) преобразует символ (строку из одного символа) в его числовой код, а chr(number) делает обратное — преобразует целое число в соответствующий ему символ.","symbols = ord(""A"")
print(symbols) #Выведет 65, т.к у этого символа такой номер

numbers = chr(48)
print(numbers) #Выведет 0, т.к у этого символа такой номер"
Цикл for,Повторение действий N-ое количество раз.,"for i in range(5):
        print(i)"
Функция range,"Генерирует итератор, ввиде последовательности целых чисел. Если вводится только 1 значение, то это будет концом (при этом сам конец не включается). Если указано 2, то первое будет началом (по умолчанию 0), в второе значение - концом. Если 3 числа, то первые два начало и конец, а 3 - шаг, т.е какая будет разница между числами. ","for i in range(5): #Числа от 0 до 4
for i in range(1, 6) #Числа от 1 до 5
for i in range(1, 10, 2) #Каждые 2 числа от 1 до 10"
Цикл while,"Повторение действий, пока условие выполняется. В самом цикле обязательно указать как изменятся счетчик, иначе цикл будет БЕСКОНЕЧНЫМ.","while k <= 5:
        print(k) k = k + 1"
Оператор break,Он останаливает цикл и выходит из него.,"for i in range(5):
        print(i) if i == 4:
        break
Цикл прекратится когда i будет равно 4."
Итерация,Это один проход цикла.,"for i in range(5):
        print(i)
Здесь: вывод i является итерацией)"
Итератор,"объект, чтобы перебирать элементы последовательности (списка, кортежа и пр.)","for i in range(5): #Функция range создает итератор - последоватльность чисел от 0 до 4
        print(i)"
List Comprehension (Списочные включения),Краткий и читаемый синтаксис для создания списков на основе существующих итераций.,"squares = []
for x in range(5):
    squares.append(x**2)
#Это был обычный способ

squares = [x**2 for x in range(5)]
#А это кратким способом, но списки у них будут одинаковыми"
"Условные операторы if, elif и else","if - начальное условие, при его выполнении выполняется код снизу. Если условия нет, то оно будет проверять есть ли этот объект вообще. elif - условие, которое будет проверено только если if не было выполнено. Если ни одно условие не было выполнено, то код будет работать по сценарию else.","if 1:
        print('True')"
Оператор is,Оно проверяет идентичные ли объекты. Может заменяться на ==.,"if 1 == 1:
        print('Yes')"
Оператор in,"Оно проверяет принадлежит ли этот объект другому, или есть ли он внутри него.","my_list = [0, 1, 2, 3, 4]
if 4 in my_list:
        print('Yes')"
"Операции and, or и not","Это логические оперцации. and - И, or - ИЛИ, not - НЕ.","if 'a' == 'a' and 'b' == 'd'
        print('Yes')"
Декомпозиция,"Это разделение сложной задачи на более мелкие и управляемые компоненты, это делет код более читаемым.",Например в Python это классы и функции.
Функции,"Блок кода, который выполняется только при вызове. Определяется с ключевым словом def, за которым следует имя функции, скобки с параметрами и двоеточиe.","def my_func(*args):
        return args * 2
#Эта функция возвращает удвоенное значение переменной"
Функция return,"Он используется внутри функции, при использоваии завершает ее выполнение и возвращает опредленное значение.",return 0
lambda функция,"Небольшая функция без имени, которая определяется ключевым словом lambda. В теле такой функции можут быть только одно выражение.","my_func = lambda x: x * 2
print(my_func(5))"
Ключевое слово global,"Используется внутри функции, когда вы хотите приосвоить новое значение переменной, которая была объявлена вне функции.","counter = 0
def my_func():
    global counter
    counter = 10
#В итоге изменится переменная не локально (внутри функции) а во всем коде (глобально)."
Функции sorted и filter,"sorted (сортировка) - меняет порядок элементов по определенному признаку, не изменяя кол-во элеменов. По умолчанию сортирует по размеру. filter (фильтрация) - выбирает элементы по определенному признаку, некоторые элементы могут быть НЕ включены в конечную выборку. Обязательно нужен ключ ввиде функции, по которой и просиходит фильтрация. Оригинальный массив они НЕ ИЗМЕНЯЮТ.","def is_even(x):
        return x % 2 == 0

my_list = [1, 5, 4, 2, 3]
sorted(my_list) #Вывод: [1, 2, 3, 4, 5]
filter(my_list, is_even) #Вывод: [2, 4] (т.е только четные)"
Декораторы,"Это функции, которые могут модифицировать поведение других функций, при этом не изменяя их исходного кода. Определяется как функция (с помощью def), а чтобы использовать ее как декоратор нужно перед названием поставить @, снизу другая функция.","def function(func):
        def wrapper(*args, **kwargs):
            # Дополнительная логика ДО вызова оригинальной функции
            print(f""--- Вызывается функция: {func.__name__} ---"")
        
            # Вызов оригинальной функции и сохранение результата
            result = func(*args, **kwargs)
        
            # Дополнительная логика ПОСЛЕ вызова оригинальной функции
            print(f""--- Функция {func.__name__} завершила работу ---"")
        
        # Возврат результата оригинальной функции
        return result
    
    # Декоратор возвращает новую (обернутую) функцию
    return wrapper
@function def say_hello(name):
    print('Hello, {name}!')"
О-большое,"Это способ оценить, насколько медленнее или быстрее будет работать программа (алгоритм). Это не точное время в секундах, а математическая запись, описывающая, как растет сложность алгоритма с ростом объема входных данных (n). При этом, О-большое рассматривает худший случай, а не средний.","O(n) (Линейная сложность): Как перебор всех карточек по одной. Если карточек 10, займет 10 шагов.
O(log n) (Логарифмическая сложность): Как бинарный поиск в отсортированной стопке. Вы делите стопку пополам, отбрасываете ненужную, и так далее.
O(n²) (Квадратичная сложность): Как если бы вы сравнивали каждую карточку с каждой другой. Если карточек 10, нужно 100 сравнений."
Рекурсия,"Метод решения задачи, при котором функция вызывает сама себя для решения более простых подзадач.","def sum_recursicve(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return n + sum_recursicve(n-1) #Здесь функция вызывает сама себя. При этом n каждый раз уменьшается на 1, а прошлое значения n осталось в памяти"
Бинарный поиск,"Это алгоритм нахождения места (игдекса) элемента в ОТСОРТИРОВАННОМ массиве. Его принцип в том, что мы многократно (рекурсивно) делим массив пополам и проверяем, есть ли в этой половние наш элемент. Его скорость O(log n)","def binary_find(lst: list, value: int) -> int: #Функция вернет нам индекс ввиде целого числа
    if not lst:
        return None #Если список пустой, то там нечего искать
    
    mid = len(lst) // 2 #Находим значение в середине без остатка
    mid_value = lst[mid]

    if value == mid_value:
        return mid #Проверка на совпадение
    elif value < mid_value:
        return binary_find(lst[:mid], value) #Если значение меньше, то функция запускается снова, но в списке будет только первая половина
    else:
        result = binary_find(lst[mid + 1:], value) #Если значение больше, то функция запускается снова, но в списке будет вторая половина
        return result + mid + 1 if result is not None else None #Если он не найдет, то вернется None (ничего)"
Быстрая сортировка,"это алгоритм, который делит большой массив на два меньших подмассива на основе опорного элемента, а затем рекурсивно сортирует каждый из них. Его главные принципы — «разделяй и властвуй», что обеспечивает в среднем O(n log n) время работы.","import random

def quicksort_random(arr):
    if len(arr) <= 1: #Если список содержит 0 или 1 элемент, он уже считается отсортированным
        return arr
    
    pivot = random.choice(arr)  #Опорный элемент может быть первым, последним или случайным(что является самым лучшым вариантом)
    left = [x for x in arr if x < pivot] #left: Содержит все элементы, которые меньше pivot.
    middle = [x for x in arr if x == pivot] #middle: Содержит все элементы, которые равны pivot. (Это важно, если в списке есть дубликаты)
    right = [x for x in arr if x > pivot] #right: Содержит все элементы, которые больше pivot.
    
    return quicksort_random(left) + middle + quicksort_random(right) #Алгоритм рекурсивно вызывает сам себя для сортировки списка left и right, а middle ставит в середину, т.к он равен опорному элементу"
Исключение,"событие, которое возникает при выполнении программы, когда что-то идет не так.","При попытке сложить разные типы данных (к примеру строку и целое число) выйдет ошибка, это и есть исключение."
"Конструкция try, except и finally","try используется для обработки ошибок в коде. В except находится код, который выполнится при ошибке. В finally код выполнится в любом случае, даже если ошибок не было.","def safe_division():
    try:
        # --- Блок TRY: Попытка выполнить потенциально опасный код ---
        # Мы пытаемся получить ввод от пользователя и преобразовать его в число.
        user_input = input(""Введите число для деления 100 на него: "")
        number = int(user_input)
        
        # Мы пытаемся выполнить деление
        result = 100 / number
        print(f""Результат деления: {result}"")

    except ValueError:
        # --- Блок EXCEPT (если произошла ошибка типа ValueError) ---
        # Это сработает, если пользователь ввел НЕ число (например, 'привет')
        print(""Ошибка! Вы ввели неверный тип данных. Пожалуйста, введите целое число."")
        
    except ZeroDivisionError:
        # --- Блок EXCEPT (если произошла ошибка типа ZeroDivisionError) ---
        # Это сработает, если пользователь ввел 0
        print(""Ошибка! Нельзя делить на ноль."")

    finally:
        # --- Блок FINALLY: Выполняется ВСЕГДА (была ошибка или нет) ---
        print(""--- Попытка операции завершена. ---"")
        print(""--- Программа продолжает работу. ---"")

safe_division()"
ООП,"Объектно-ориентированное программирование - это подход к написанию программ, который имитирует взаимодейтсвие реальных объектов. Она рассматривает программу как набор предметов, взаимодействующих друг с другом.","Вы строите дом не по отдельным кирпичам, а разделяете весь дом на разные части и собираете его как конструктор. Кстати, данная программа тоже создана с пмощью ООП)"
Классы,"Шаблоны или чертежи для создания объектов. Они определяют набор свойств (атрибутов) и действий (методов), которые будут присущи всем объектам этого класса. Определятся с ключевым словом class.","class Buildings():
        def __init__(self):
            self.type = type
            self.heigth = height
            self.year = year
        def get_info():
            print(f""Type: {self.type}, height: {self.height}, year: {self.height}"")"
Инкапсуляция,"Проще говоря это и есть создание класса, т.е объединение переменных и функций внутри одного объекта (класса). Но также это ограничение доступа к данным и методам внутри этого класса во избежание ошибок.",class MyClass(): def __str__(self): (__str__ - это приватный атрибут)
Наследование,"Это механизм, который позволяет создавать новые классы на основе уже существующих. Новый класс наследует свойства и методы родительского класса, что позволяет повторно использовать код не создавая множество одинаковых классов. Вы можете использовать ключевое слово class для создания нового класса и указать базовый класс в скобках.",class Schools(Buildings): (подразумеватся что класс Buildings уже есть)
Полиморфизм,Способность разных объектов по-разному реагировать на одно и то же действие (вызов одной и той же функции).,"У собаки и у кошки есть действие 'издать_звук()', но, используя полиморфизм, собака будет издавать лай, а кошка мяукание"
Абстракция,"Простыми словами: Сосредоточение на том, что объект делает, а не на том, как он это делает. Сокрытие сложных деталей.","Вы используете телефон, и чтобы позвонить вам не нужно знать как этот сигнал преобразуется в элетромагнитные волны, передается на сервера, как запрос отправляется на телефон другого человека и т.д. Все детали скрыты под крышкой"
Модуль,"Файл Python, который можно импортировать в локальное пространство вашего файла с пмошью import. Если хотите несколько то from (имя файла) import (названия функций). Чтобы импортировать все, нужно написать import *.",import sys
Менеджер контекста,"Объект, который управляет ресурсами (например, файлами или сетевыми соединениями), автоматически открывая и закрывая их, часто используется с оператором with.","with open('file_name.txt', 'r') as file: #Здесь файл открывается для чтения с именем file
        content = file.read() #Создает ""читателя"", который и сканирует наш файл
        print(content) #Выводит то, что он прочитал в файле
#Так как блок with завершился, то он автоматически закроет файл"
JSON,"JavaScript Object Notation - текстовой формат обмена данными. В питоне предустановлена библиотека json и она может использоваться если вы работаете с несколькими языками, а вам нужно использовать одну и ту же информацию.","my_list = json.dumps(['apple', 'orange', 'avacado', 'onion'] (.dumps() - метод json, который запаковывает данные в этот формат)"
pip (Pip Installs Packages),"Это стандартный менеджер пакетов Python для установки, обновления и удаления сторонних библиотек через командную строку.",(Пишется в консоль) pip install <название библиотеки>
